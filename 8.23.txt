docker：
build one，run everywhere

在容器内运行的程序仅可适用于为该容器分配的资源，例如：CPU，内存，磁盘，进程空间，用户，网络，卷等；
在使用有限的容器资源的同时，并不与其他容器冲突。可以将容器视为简易计算机上运行应用程序的隔离沙箱；

容器利用底层Linux内核的功能，而不是虚拟机采用的hypervisor的方法。换句话说，容器调用Linux命令来分配和隔离出一组资源
然后再此空间中运行您的应用程序；

Namespaces：Linux namespace 允许用户在独立进程之间隔离CPU等资源，进程的访问权限及可见性仅限于器所在的Namespaces；

可以在同一个机器上不同容器中运行具有相同PID的进程。两个不同容器中的应用程序可以使用相同的端口


Docker工作原理：通过使用Linux namespace和cgroup来协调配置容器，将应用程序文件复制到容器分配的磁盘，然后运行启动命令。

微服务：
zookeeper：分布式应用正在运行的一组应用被称为集群，而在集群中运行的每台机器被称为节点
分布式应用有两个部分：Server（服务端）和Client（客户端）服务器应用程序实际上是分布式的，并具有通用的接口，以便客户端可以连接到
集群中的任何服务器并获得相同的结果。客户端应用程序是与分布式应用进行交互的工具；
Zookeeper是由集群使用的一种服务，用于在自身之间协调，并通过稳健的同步技术维护共享数据。Zookeeper本身是一个分布式应用程序，为写入分布式应用程序提供服务；
服务：
命名服务、配置管理、集群管理、选举算法、锁定和同步服务、高度可靠的数据注册表
竞争条件和死锁的使用故障安全同步方法进行处理，数据不一致性，zookeeper使用原子性解析。

Architecture（架构）、Hierarchi namespace（层次命名空间）、Session（会话）、Watchs（监视）
客户端：我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端想服务器发送消息以使服务器知道客户端是活跃的。
类似地，当客户端俩介绍，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一服务器；
服务器：Zookeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的；
Ensemble：zookeeper服务器组，形成ensemble所需的最小节点为3.
Leader：服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。
Follower：跟随leader指令的服务器节点

层次命名空间：Zookeeper的节点称为znode，每个znode由一个名称标识，并用路劲（/）序列分割。

redis持久化：
RDB和AOF
RDB：
命令save：服务器会阻塞save后面的命令，等待save处理完成；
bgsave：redis会从主线程fork一个子线程，redis服务器在处理bgsave采用子线程进行IO写入，而主线程任然可以接受其他请求，但forks子线程是同步的，所以forks子进程时，一样不能接收其他请求，
所以forks一个子线程花费的时间太久，bgsave命令仍然有阻塞其他客户的请求的情况发生。

rdb文件：生成临时rdb文件，并写入数据
完成数据写入，用临时rdb替代正式rdb文件
删除原来的db文件

服务器配置自动触发：
save 900 1   900s内至少达到一条写命令

通过rdb恢复文件数据比较快
通过RDB进行数据备份，由于使用子进程生成，所以对服务器性能影响较小；


AOF：
AOF持久化会记录客户端对服务端的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件的末尾，在redis服务器重启时，会加重并运行aof文件的命令，以恢复数据

RDBvsAOF
RDB恢复快，对服务器性能影响小；AOF文件体积大，恢复速度慢

