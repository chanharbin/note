分布式锁
redis实现异步队列
BIO、NIO
垃圾回收


分布式锁是控制分布式系统之间共同访问共享资源的一种方式。如果不同的系统或同一系统的不同主机之间共享了一个或者一组资源，那么访问这些资源的时候，往往需要通过一些互斥手段防止彼此之间干扰，保证一致性。
有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，java中其实提供了很多并发的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的JAVAAPI并不能提供分布式锁的能力。所以针对分布式锁的实现目前有很多方案：
1、数据库锁
2、基于redis的分布式锁
3、基于Zookeeper的分布式锁

分布式锁应该怎么样：
互斥性：保证分布式部署的应用集群中，每一个方法在同一时间只能被一台机器上的一个线程执行
这把锁要是一把可重入锁（避免死锁）
不会产生死锁：有一个客户端在持有锁的过程中崩溃而没有解锁，也能保证其他客户端能够加锁
这把锁最好是阻塞锁
有高可用的获取锁和释放锁的功能
分布式锁
数据库锁：
要实现分布式锁，最简单的方式就是直接创建一张锁表（id，methodname，desc，updatetime）方法名唯一，然后通过操作该表中的数据来实现了。
当我们要锁住某个方法或者资源的时候，我们就在该表中增加一条记录（insert into methodLock method_name,desc) values('method_name','desc')，想要释放锁的时候就删除这条记录
我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库，数据库会保证只有一个操作可以成功
问题：
如果数据库是单点的，一旦数据库挂掉，会导致业务系统整个不可用；
这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁；
这把锁是非阻塞的，一旦失败就直接报错。没有获得锁的线程并不会进入排队队列，想再次获得锁就要再次触发锁操作。、
非重入的，同一个线程先没有释放锁之前无法再次获得该锁。因为数据中数据已经存在。（数据库表加字段，当前获得锁的主机信息和线程信息，那么下次获取锁先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可）
使用数据库排他锁：
开启事务，还是这个数据库锁表，先插入一行数据，执行select...for update，哪个线程获取到数据库排他锁则认为获取到分布式锁，释放锁的方法是提交事务（可解决阻塞锁和无法释放锁的问题）
总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。

乐观锁：时间戳记录机制：给数据库表增加一个时间戳字段类型的字段，当读取数据时将时间戳一起读出，数据每更新一次则将时间戳也更新，进行数据更新操作前，检查当前数据库中的数据的时间戳和自己查出来的时间戳对比，一致则更行，不一致则认为是失效数据；
出现冲突由上层逻辑修改，启动重试机制；
同样可以使用version实现


基于redis的分布式锁：
加锁就一行代码：jedis.set(String key,String value,String NX,String PX,int time)
key，使用key来当锁，因为key 是唯一的；
value，我们传的是requestId，有key作为锁并不足够，分布式锁要满足解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的，释放锁的时候会先检查请求的Id是否一致，否则不能释放；
NX：Set if Not Exist 若key不存在则进行set操作，若key已经存在，则不做任何操作；
PX：给这个key加一个过期的设置，具体时间由第五个参数time决定；
time：过期时间
执行上面的set方法：1、当前没有锁，执行加锁操作，并设置过期时间，同时value表示加锁的客户端；2 已有锁存在，则不做任何操作；
错误示例是使用jedis.setnx()和jedis.expire()组合实现加锁，由于两条命令不具有原子性，如果程序在执行完setnx（）崩溃，则没有设置锁的过期时间；
解锁：首先获取锁对应的value值，检查是否与requestId相等，相等则删除锁；

基于zookeeper的分布式锁：
Zookeeper分布式锁应用了临时顺序节点，具体如何实现呢？
获取锁：
首先Zookeeper当中创建一个持久节点ParentLock。当第一个客户端想要获得锁时，需要在ParentLock节点下面创建一个临时顺序节点Lock1；
之后，Client1查找ParentLock下面的所有临时顺序节点并排序，判断自己所创建的节点Lock1是不是顺序最靠前的一个，如果是第一个节点，则成功获得锁。
这时候，如果再有一个客户端client2前来获取锁，则在parentLock下再创建一个临时节点Lock2；
Client2查找ParentLock下面所有的临时顺序节点并排序，判断自己所创建的节点Lock2是不是最靠前的一个，结构发现Lock2并不是最小的。
于是，Client2向排序仅比它靠前的节点Lock1注册Watcher，用于监听Lock1节点是否存在，这意味着Client2抢锁失败，进入了等待状态。
这时候，如果又有client3前来获取锁，则在ParentLock下再创建一个临时顺序节点Lock3
Client3查找ParentLock下面的所有临时顺序节点，判断自己所创建的节点是不是最靠前的一个，结果同样发现节点Lock3并不是最小的。
于是Client3向排序仅比它靠前的节点Lock2注册Watcher，用于监听Lock2节点，同样Client3同样抢锁失败，进入了等待状态。
这样一来，Client1得到锁，Client2监听了Lock1，Client3监听了Lock2.

释放锁：
两种情况：
1、任务完成，客户端显式释放
当任务完成时，Client1会显式调用删除节点Lock1的指令。
2、任务执行过程中，客户端崩溃
获得锁Client1在任务执行过程中，如果Duang崩溃，则会断开与Zookeeper的连接，根据临时节点的特性，相关联的节点Lock1会随之自动删除。

由于Client2一直监听者Lock1的存在状态，当Lock1节点被删除，Client2会立刻收到通知，这时候如果Client2会再次查询ParenLock下面的所有节点，确认自己创建的节点Lock2是不是目前最小的节点。
如果是最小，则Client2顺理成章获得了锁；Client3同理；
可以直接使用zookeeper第三方库Curator客户端，客户端封装了一个可重入锁的服务：
interProcessMutex.acquire(）加锁   interProcessMytex.release()释放锁；



分布式锁问题：如果执行业务的代码的时间超过了锁的过期时间，锁释放了而代码还在执行，有可能会造成分布式不安全的情况，怎么解决；








