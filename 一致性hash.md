一致性hash

凡是涉及到分布式的系统，就会有负载均衡和数据分布的问题。为了让连接（或者数据）能够分布得更均匀，很多时候会使用到Hash算法



Hash算法：

把任意长度得输入，通过Hash算法变换成固定长度的输出，这个输出就是Hash值，哈希值的空间远小于输入的空间，所以可能会发生“哈希碰撞”，即两个不同的输入产生了同一个输出。



负载均衡

先Hash再取模，在负载均衡中十分常见

hash(request)%n

假设我们现在有三个服务器，想要做负载均衡，就可以对请求的ip地址或者用户id等使用hash函数，然后计算得出hash值对3取模，余数为几，就把请求分配到相应的服务器上



弊端：

在分布式场景下，横向伸缩是一个很正常的需求。试想，当上述的3台服务器需要扩展到4台服务器，那绝大多数请求基本上都需要重新映射到另一个节点。因为Hash值没变，除数变了，余数必然会变

这种变动有时候是不能接受的。比如在Web负载均衡的情景下，session会保存在每个节点里，如果是“无状态”的服务，那不会存在这个问题。但如果数据持久化场景，这种大的变动显然是不能接受的。因为如果增加或者删除了一个节点，就会导致导致几乎所有的数据都需要重新迁移。



一致性hash

使用一致性Hash可以解决因为横向伸缩导致的大规模数据变动。

用节点数量作为除数去求余。而一致性Hash的除数是2^32.从0到2^32-1，首位相连构成一个环，我们先对服务器节点的IP进行hash，然后除以2^32得到服务器节点在这个Hash环中的位置：

现在有请求过来了，同样进行Hash然后处于2^32求余。如果落在Hash环上，然后顺时针找到第一个节点，这个节点就负责处理这个请求；



分布不均匀问题：

一致性hash算法在节点数量较少的时候，会出现分布不均匀的问题

解决方法：在Hash环上增加虚拟节点

实现方式很多，比如：

hash("SERVER_IP_A#1")%2^32

一致性Hash有什么用？

除了前面提到的负载均衡，Web session和数据库分库分表可以应用外，其实一致性Hash应用得最多的领域是分布式缓存

