Head堆区：程序计数器，本地方法栈，虚拟机栈、内存堆、方法区（元数据区）
虚拟机栈，本地方法栈和程序计数器3个区域随线程而生，随线程而灭，不需要过多考虑回收的问题；
而内存堆和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分；
垃圾收集器在对堆区和方法区回收前，首先确定这些区域的对象哪些可以被回收，哪些暂时不能回收，这就要判断对象是否存活的算法；

1、引用计数算法：
垃圾收集器中早期策略。在这种方法中，堆中的每个对象实例都有一个引用计数，当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1
当任何其他变量被赋值为这个对象的引用时，计数加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减一。
任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1.
引用计数器可以很快的执行，交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利。
缺点：无法检测出循环引用。如父对象有一个子对象的引用，而子对象反过来引用父对象。这样，他们的引用计数永远不可能为0
2、可达性分析算法：
从一个GCRoot开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将被判定为可回收的对象；
可达性分析算法不会出现对象间循环引用的问题。GCRoot在对象图之外，是特别定义的“起点“，不可能被对象图内的对象所引用。
对象生存还是死亡？
即使在可达性分析算法中不可达的对象，也并非非死不可，要真正宣告一个对象死亡，至少要经历两次标记过程：若果对象在进行可达性分析后，发现没有与GCRoot相连接的引用链，那它将会被第一次标识并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，
若对象没有覆盖finalize方法或者对象的finalize被虚拟机调用了，虚拟机将这两种情况都视为”没有必要执行“

Java的引用
强引用，软引用，弱引用和虚引用
强引用：在程序代码中普遍存在，类似与Object object = new Object()这种；
软引用：描述一些有用但并非必须的对象；在系统发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收，如果这次回收之后还没有足够的内存，才会抛出内存溢出异常。
弱引用：当垃圾回收器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象
虚引用：能在对象被收集器回收时收到一个系统通知

对象死亡（被回收前）两次标注：
如果对象在进行可达性分析后发现没有与GCroot相连接的引用链，会被第一次标识；
第一次标识后会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，在finalize()方法中没有重新与引用链建立连接的对象，将被二次标识；
两次标识的对象真的会被回收，而若在finalize()方法中重新建立了与GCroot引用链的对象曾逃离，但只能进行一次自我救赎；


常用的垃圾收集算法：
0、引用计数法：
给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器加1，当引用失效时，计数器减1 当计数器为0时表示该对象不可被引用了；（很难解决对象互相引用）
1、标记-清除算法：
标记阶段和清除阶段：标记阶段标记存活的对象，清除阶段扫描整个空间将未被标识的对象进行回收。（产生大量内存碎片）
2、复制算法：
将内存划分为大小相等的两块，每次只使用其中一块内存，垃圾回收时将存活的对象复制到另一块内存空间上，然后将已用的内存空间清空（内存空间缩小，效率取决于存活的对象的多少）
3、标记-整理算法：和标记清除算法类似，但是在完成对象的标识后，不是直接清理可回收的对象，而是将存活对象向一端移动；
即在清理完对象后，将存活的对象向左端移动，并更新空闲指针；
4、分代收集算法：
根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况将堆区划分为老年代和新生代，在堆区之外还有一个代就是永久代。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么可以根据不同代的特点采取最适合的收集算法
新生代采取复制算法，因为新生代每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少
新生代内存按照8：1：1比例分为一个eden区和两个survicor（s0，s1）。大部分对象在eden区生成 回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存满了，则将eden区和survivor0区存活的对象复制到另一个另一个survivor1区，然后清空eden区和这个survivor区，此时survivor0区为空，然后交换survivor0区和survivor1区；（MinorGC）
当survivor1区不足以存放eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次FullGC（Maior GC）也就是新生代、老年代都进行回收；

垃圾回收器的分类：
Serial回收器：采用串行单线程的方式，其中stop the world，即垃圾回收的某个阶段会暂停整个程序的执行。
CMS回收器：Concurrent Mark Sweep Collector，回收停顿时间比较短、目前比较常用的垃圾回收器。通过初始标识，并发标识，重新标识、并发清除四个步骤完成垃圾回收工作；
1、3步初始标识和重新标识依然会引发STW，而第二四步并发标识和并发清除两个阶段可以和应用程序并发执行。由于CMS采用的是”标识-清除算法“因此产生大量的空间碎片。为了解决这个问题，CMS可以通过配置-XX：+UserCMSCompactAtFullCollection，强制JVM在FGC完成后堆老年代进行压缩。
但是空间碎片整理阶段也会引发STW，为了减少STW次数，CMS可以配置-XX:+CMSFullGCsBeforeCompaction=n参数，在执行了n次FGC后，JVM再在老年代执行空间碎片整理。



