CPU -> 内存
CPU -> 缓存 -> 内存
CPU1 -> L1 ;  CPU2 -> L2 ;  CPU1和CPU2共享一份内存；
缓存一致性和指令重排
处理器优化 处理器会对输入的代码进行乱序执行处理

指令重排：JIT

原子性问题（long和double类型的变量赋值不具有原子性，需要被volatile）；可见性问题；有序性问题
处理器优化；缓存一致性；指令重排

保证共享内存的正确性（可见性、有序性和原子性），内存模型定义了共享内存系统的多线程程序读写操作行为的规范；
JAVA内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存
线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存；不同线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递
均需要自己的工作内存和主内存之间进行数据同步进行。

JMM作用与工作内存和主存之间数据同步过程。规定了如何做数据同步以及什么时候做数据同步。

为了保证原子性，monitorenter和monitorexit  -> synchronized  （原子性）

可见性问题  volatile  被其修饰过的变量每次修改都可以立即同步到主内存；被其修饰过的变量每次用之前从主存刷新；
volatile ：volatile通过在volatile变量操作前后插入内存屏障的方式，保证了变量在并发场景的有序性和可见性

synchronized：原子性，可见性，一致性
被其修饰的代码，同一时间内只能被一个线程访问；
修改同步方法：通过ACC――SYNCHRONIZED 标识；
方法级别的同步是隐式的；同步方法的常量池中会有一个ACC_SYNCHRONIZED变量，若有设置，需要先获得
监视器锁  然后开始执行方法；方法执行之后再释放监视器锁；
！！！若方法抛出异常并且没有被捕获，则会释放监视器锁；
monitorenter和monitorexit monitorenter和monitorexit 理解为加锁和释放锁；每个对象维持
一个记录被锁次数的计数器，每次获取到锁则加一，执行monitorexit 计数器减一  当计数器为0时；
锁才释放；

可见性：对一个变量解锁前，必须先把变量同步回主存当中；

自旋锁、锁优化、锁消除
修饰代码块：monitorenter 和moniterexit


synchronized和volatile
synchronized有性能消耗；volatile在读场景的消耗与普通变量无异；在写操作由于需要插入内存屏障会略慢，但整体比synchronized快；
synchronized本质上实现的是阻塞锁；也就是说多个线程要排队等待同一个共享对象；
volatile是基于内存屏障实现的，并不是锁；
volatile并不能保证操作的原子性，所以在当前变量依赖与变量之前值的操作时需要加synchronized；
synchronized 并不能保证线程内部的指令有序性  但能保证线程运行的有效性，从线程外部看来最终的结果都是as-if-serial；所以
若是需要保证线程内部的指令重排，或许得加volatile；

