2PC、3PC和TCC

2PC（两阶段提交）：强一致、中心化的原则提交协议

这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和N个参与者节点（participants）

第一阶段：请求/表决阶段

在分布式事务的发起方在向分布式事务协调者（Coordinator）发送请求时，Coordinator首先会分布向参与者节点A（Participant）和参与者节点B（Participant）分布发送事务预处理请求，称之为Prepare

直白点就是问一下这些参与节点”这件事你们能不能完成“此时这些参与者节点一般就会打开本地数据库事务，然后开始执行数据库本地事务，但在执行完成后并不会立马提交数据库本地事务，而是先向Coordinator报告说”我这边可以处理/我这边不能处理“

如果所有的参与者节点都向协调者做了”Vote Commit“的反馈的话，那么此时流程就会进入第二个阶段了；

第二个阶段：提交/执行阶段（正常流程）

如果所有参与者节点都向协调者报告说”我这边可以处理“，那么此时协调者就会向所有参与者节点发送全局提交确认通知（global_commit)即你们都可以进行本地事务提交了，此时参与者节点就会完成滋生本地数据库的提交，并最终将提交结果回复“ack”消息给Coordinator，然后Coordinator就会向调用方返回分布式事务处理完成的结果

第二阶段：提交/执行阶段（失败流程）

相反，在第二阶段除了所有的参与者节点都反馈“我这边可以处理了”的情况外，也会有节点说“我这边不能处理”的情况发生，此时参与者节点就会向协调者节点反馈“Vote_Abort”此时分布式事务协调者系欸但就会向所有参与者节点发起事务回滚的消息（global_rollback“）此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送”ack“确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果

异常情况：假设如果在第二个阶段中Coordinator在接收到Participant的”Vote_Request"后挂掉或者网络出现了异常，那么此时Participant节点就会一直处于本地事务挂起的状态，从而长时间地占用资源。当然这种情况只会出现在极端地情况下，然而作为一套健壮地软件系统而言，异常Case的处理才是真正考验方案正确性的地方；



问题：

1、性能问题：

最大的缺点就在于它的执行过程中间，节点处于阻塞状态。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点都准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源，这个过程会比较漫长，对性能影响比较大



2、协调者单点故障问题：

事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚通知，从而导致参与者节点始终处于事务无法完成的中间状态



3、丢失消息导致数据不一致的问题：

在第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就会导致节点间的数据不一致问题



三阶段提交（3PC）

三阶段提交又称为3PC，其在两阶段提交的基础上增加了CanCommit阶段，并引入了超时机制。一旦事务参与者迟迟没有收到协调者的Commit请求，就会自动进行本地Commit，这样相对有效地解决了协调者单点故障问题

流程：

第一阶段：CanCommit阶段：这个是一种事务询问操作，事务协调者向所有参与者询问“你们是否可以完成本次事务”，如果参与者节点认为自身可以完成事务就返回“YES”，否则“NO”。而在实际的场景中参与者节点会对自身逻辑进行事务尝试，其实说白了就是检查下自身的状态的健康性，看有没有能力进行事务操作。

第二阶段：PreCommit阶段：

在阶段一中，如果所有的参与者都返回yes的话，那么就会进入PreCommit阶段进行事务预提交。此时分布式事务协调者会向所有的参与者节点发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和ReDO消息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈ACK表示我已经准备好提交了，并等待协调者的下一步指令

否则，如果阶段一中有任何一个参与者节点返回的结果是NO响应，或者协调者在等待参与者节点反馈的过程中超时（2PC中只有协调者可以超时，参与者没有超时机制）整个分布式事务就会中断，协调者就会向所有的参与者发送“abort"请求

第三阶段：DoCommit阶段：

在阶段2中如果所有参与者节点都可以进行PreCommit提交，那么协调者就会从”预提交状态“->”提交状态“ 然后向所有参与节点发送”doCommit“请求	参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈”Ack“消息，协调者收到所有参与者的ACK消息后完成事务。

相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务；



2PCVS3PC

相比较2PC而言，3PC对于协调者和参与者都设置了超时时间，而2PC只有协调者才拥有超时机制。这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而释放资源，而这种机制也侧面降低了整个事务的阻塞时间和范围



TCC（try-confirm-cancle）

补偿事务，核心思想：“针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）” 它分为三个操作：

Try：主要是对业务系统做检测及资源预留。

Confirm： 确认执行业务操作

cancel：取消执行业务操作

TCC事务处理流程和2PC两阶段提交类似，不过2PC通常都是在跨库的DB层面，而TCC本质上就是一个应用层面的2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突，提高吞吐量成为可能

不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作，此外，其实现难度也比较大，需要按照网络状态，系统故障等不同的失败原因实现不同的回滚策略



