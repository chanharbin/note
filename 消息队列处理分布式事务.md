消息队列处理分布式事务：

在系统变的复杂后，分布式，微服务等架构技术，就要考虑到应用在系统中了。尤其数据量打了后，就需要对数据库进行划分

一旦数据库进行了分拆，那就出现很多头疼的问题，其中之一就是事务问题

具体的业务场景：

用户A转账100元给用户B，具体的步骤：

1、用户A的账户先扣除100元

2、再把用户B的账号加100元



问题：转账业务有两步，一个操作用户A扣钱，一个操作用户B加钱

如果在同一个数据库中进行，可以保证这两部操作，要么同时成功，要么同时不成功

但是如果用户A的数据在集群A中，用户B在集群B中，因为他们不在同一个事务中，数据就不一致了；

类似这种问题微服务架构会很多，因为每个服务都是独立的模块，都是远程调用

都没法在同一个食物中，都会遇到事务问题



两阶段提交，TCC，最终一致性方案

消息中间件解决：

消息中间件方案：![1569378306390](C:\Users\chenhaobin6\AppData\Roaming\Typora\typora-user-images\1569378306390.png)

利用消息中间件的方式，把扣款业务和加钱业务异步化，扣款成功发送扣款成功消息到消息中间件，加钱业务订阅“扣款成功消息”再对用户B加钱

问题：

1、先扣款后发消息：先扣款再发消息，若扣款成功而发送消息失败，那用户B就没法加钱

2、先发消息后扣款：万一扣款失败，可加钱业务订阅到了消息，用户B加了钱



RocketMQ事务方案：

RocketMQ消息中间件把消息分为两个阶段：Prepared阶段和确认阶段

Prepared（预备阶段）

该阶段主要发一个消息给rocketmq，但该消息只储存在commitlog中，但consumequeue中不可见，就是消费端（订阅端）无法看到此消息

commit阶段/rollback阶段（确认阶段）

该阶段主要是把prepared消息保存到consumeQueue中，即让消费端可以看到此消息，也就是可以消费此消息

![1569379111735](C:\Users\chenhaobin6\AppData\Roaming\Typora\typora-user-images\1569379111735.png)



流程：1、在扣款前，先发送预备消息

2、发送预备消息成功后，执行本地扣款事务

3、扣款成功后，再发送确认消息

4、消费端（加钱业务看到确认消息）消费此消息，进行加钱

确认消息说明：

上面的确认消息可以为commit消息，可以被订阅者消费，也可以是rollback消息，即执行本地扣款事务失败后，提交rollback消息，即删除哪个预备消息，订阅者无法消费；

异常：

发送确认消息失败，扣钱成功而加钱失败

解决方案：

RocketMQ回查：

核心思路是状态回查，也就是rocketmq会定时遍历commitlog中的预备信息

因为预备信息最终肯定变为commit或rollback消息，所以遍历预备消息去回查本地业务的执行状态，如果发现本地业务没有执行成功就rollback，如果执行成功就发哦送commit消息

上面的异常，发送预备消息成功，本地扣款事务成功，但发送确认消息失败，因为rocketmq会进行回查预备消息，在回查后发现业务已经扣款成功了，就补发“发送commit确认消息”；这样加钱业务就可以订阅此消息了

回查判断业务是否成功：

设计一张Transaction表，将业务部和Transaction绑定在同一个本地事务，如果扣款本地事务成功，Transaction中应当已经记录该TransactionId的状态为已完成。当RocketMQ回查时，只需要检查对应的TransactionId的状态是否是“已完成”就好，而不用关心具体的业务数据

